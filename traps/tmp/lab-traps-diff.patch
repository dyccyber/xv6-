diff --git a/Makefile b/Makefile
index 7a7e380..bc4d47a 100644
--- a/Makefile
+++ b/Makefile
@@ -188,6 +188,7 @@ UPROGS=\
 	$U/_grind\
 	$U/_wc\
 	$U/_zombie\
+	$U/_alarmtest\
 
 
 
diff --git a/answers-traps.txt b/answers-traps.txt
new file mode 100644
index 0000000..65da4f3
--- /dev/null
+++ b/answers-traps.txt
@@ -0,0 +1,10 @@
+(1)在a0-a7中存放参数，13存放在a2中
+(2)在C代码中，main调用f，f调用g。而在生成的汇编中，main函数进行了内联优化处理。
+从代码li a1,12可以看出，main直接计算出了结果并储存
+(3)在0x630
+(4)0x38
+(5)57616=0xE110，0x00646c72小端存储为72-6c-64-00，对照ASCII码表
+72:r 6c:l 64:d 00:充当字符串结尾标识
+因此输出为：HE110 World
+若为大端存储，i应改为0x726c6400，不需改变57616
+(6)原本需要两个参数，却只传入了一个，因此y=后面打印的结果取决于之前a2中保存的数据
\ No newline at end of file
diff --git a/kernel/defs.h b/kernel/defs.h
index 3564db4..358c1de 100644
--- a/kernel/defs.h
+++ b/kernel/defs.h
@@ -80,7 +80,8 @@ int             pipewrite(struct pipe*, uint64, int);
 void            printf(char*, ...);
 void            panic(char*) __attribute__((noreturn));
 void            printfinit(void);
-
+//新添加
+void            backtrace(void);
 // proc.c
 int             cpuid(void);
 void            exit(int);
@@ -145,6 +146,8 @@ void            trapinit(void);
 void            trapinithart(void);
 extern struct spinlock tickslock;
 void            usertrapret(void);
+int sigalarm(int ticks, void (*handler)());
+int sigreturn(void);
 
 // uart.c
 void            uartinit(void);
diff --git a/kernel/printf.c b/kernel/printf.c
index e1347de..9a68394 100644
--- a/kernel/printf.c
+++ b/kernel/printf.c
@@ -49,6 +49,20 @@ printint(int xx, int base, int sign)
     consputc(buf[i]);
 }
 
+
+void
+backtrace(void)
+{
+  uint64 fp = r_fp();
+  printf("backtrace:\n");
+  uint64 ret_addr;
+  while ((PGROUNDUP(fp) - PGROUNDDOWN(fp)) == PGSIZE){
+    ret_addr = *((uint64*)(fp-8));
+    printf("%p\n", ret_addr);
+    fp = *((uint64*)(fp-16));
+  }
+}
+
 static void
 printptr(uint64 x)
 {
diff --git a/kernel/proc.c b/kernel/proc.c
index 22e7ce4..f527519 100644
--- a/kernel/proc.c
+++ b/kernel/proc.c
@@ -134,6 +134,20 @@ found:
     release(&p->lock);
     return 0;
   }
+  
+
+  //新添加
+  // Allocate a trapframe page for alarm_trapframe.
+  if((p->alarm_trapframe = (struct trapframe *)kalloc()) == 0){
+    release(&p->lock);
+    return 0;
+  }
+  p->alarm_interval = 0;
+  p->alarm_handler = 0;
+  p->alarm_ticks = 0;
+  p->alarm_goingoff = 0;  
+
+
 
   // Set up new context to start executing at forkret,
   // which returns to user space.
@@ -155,6 +169,17 @@ freeproc(struct proc *p)
   p->trapframe = 0;
   if(p->pagetable)
     proc_freepagetable(p->pagetable, p->sz);
+  
+  //新添加
+  if(p->alarm_trapframe)
+    kfree((void*)p->alarm_trapframe);
+  p->alarm_trapframe = 0;
+  p->alarm_interval = 0;
+  p->alarm_handler = 0;
+  p->alarm_ticks = 0;
+  p->alarm_goingoff = 0;
+
+
   p->pagetable = 0;
   p->sz = 0;
   p->pid = 0;
diff --git a/kernel/proc.h b/kernel/proc.h
index f6ca8b7..cd03d89 100644
--- a/kernel/proc.h
+++ b/kernel/proc.h
@@ -105,4 +105,13 @@ struct proc {
   struct file *ofile[NOFILE];  // Open files
   struct inode *cwd;           // Current directory
   char name[16];               // Process name (debugging)
+
+  int alarm_interval;         
+  void(*alarm_handler)();     
+  int alarm_ticks;            
+  struct trapframe *alarm_trapframe;  
+  int alarm_goingoff;         
+
+
+
 };
diff --git a/kernel/riscv.h b/kernel/riscv.h
index 1691faf..c172fbc 100644
--- a/kernel/riscv.h
+++ b/kernel/riscv.h
@@ -6,6 +6,14 @@ r_mhartid()
   asm volatile("csrr %0, mhartid" : "=r" (x) );
   return x;
 }
+//new add
+static inline uint64
+r_fp()
+{
+  uint64 x;
+  asm volatile("mv %0, s0" : "=r" (x) );
+  return x;
+}
 
 // Machine Status Register, mstatus
 
diff --git a/kernel/syscall.c b/kernel/syscall.c
index c1b3670..24bfccd 100644
--- a/kernel/syscall.c
+++ b/kernel/syscall.c
@@ -104,6 +104,8 @@ extern uint64 sys_unlink(void);
 extern uint64 sys_wait(void);
 extern uint64 sys_write(void);
 extern uint64 sys_uptime(void);
+extern uint64 sys_sigalarm(void);
+extern uint64 sys_sigreturn(void);
 
 static uint64 (*syscalls[])(void) = {
 [SYS_fork]    sys_fork,
@@ -127,6 +129,8 @@ static uint64 (*syscalls[])(void) = {
 [SYS_link]    sys_link,
 [SYS_mkdir]   sys_mkdir,
 [SYS_close]   sys_close,
+[SYS_sigalarm] sys_sigalarm,
+[SYS_sigreturn] sys_sigreturn,
 };
 
 void
diff --git a/kernel/syscall.h b/kernel/syscall.h
index bc5f356..c09f4bd 100644
--- a/kernel/syscall.h
+++ b/kernel/syscall.h
@@ -20,3 +20,5 @@
 #define SYS_link   19
 #define SYS_mkdir  20
 #define SYS_close  21
+#define SYS_sigalarm 22
+#define SYS_sigreturn 23
\ No newline at end of file
diff --git a/kernel/sysproc.c b/kernel/sysproc.c
index e8bcda9..98ae847 100644
--- a/kernel/sysproc.c
+++ b/kernel/sysproc.c
@@ -7,6 +7,27 @@
 #include "spinlock.h"
 #include "proc.h"
 
+
+
+
+// sysproc.c
+uint64 sys_sigalarm(void) {
+  int n;
+  uint64 fn;
+  if(argint(0, &n) < 0)
+    return -1;
+  if(argaddr(1, &fn) < 0)
+    return -1;
+  
+  return sigalarm(n, (void(*)())(fn));
+}
+
+uint64 sys_sigreturn(void) {
+	return sigreturn();
+}
+
+
+
 uint64
 sys_exit(void)
 {
@@ -69,6 +90,8 @@ sys_sleep(void)
     }
     sleep(&ticks, &tickslock);
   }
+  //new add
+  backtrace();
   release(&tickslock);
   return 0;
 }
diff --git a/kernel/trap.c b/kernel/trap.c
index a63249e..eb14ccb 100644
--- a/kernel/trap.c
+++ b/kernel/trap.c
@@ -16,6 +16,24 @@ void kernelvec();
 
 extern int devintr();
 
+
+// trap.c
+int sigalarm(int ticks, void(*handler)()) {
+  // 设置 myproc 中的相关属性
+  struct proc *p = myproc();
+  p->alarm_interval = ticks;
+  p->alarm_handler = handler;
+  p->alarm_ticks = ticks;
+  return 0;
+}
+
+int sigreturn() {
+  // 将 trapframe 恢复到时钟中断之前的状态，恢复原本正在执行的程序流
+  struct proc *p = myproc();
+  *p->trapframe = *p->alarm_trapframe;
+  p->alarm_goingoff = 0;
+  return 0;
+}
 void
 trapinit(void)
 {
@@ -77,9 +95,21 @@ usertrap(void)
     exit(-1);
 
   // give up the CPU if this is a timer interrupt.
-  if(which_dev == 2)
+  if(which_dev == 2) {
+    if(p->alarm_interval != 0) { // 如果设定了时钟事件
+      if(--p->alarm_ticks <= 0) { // 时钟倒计时 -1 tick，如果已经到达或超过设定的 tick 数
+        if(!p->alarm_goingoff) { // 确保没有时钟正在运行
+          p->alarm_ticks = p->alarm_interval;
+          // jump to execute alarm_handler
+          *p->alarm_trapframe = *p->trapframe; // backup trapframe
+          p->trapframe->epc = (uint64)p->alarm_handler;
+          p->alarm_goingoff = 1;
+        }
+        // 如果一个时钟到期的时候已经有一个时钟处理函数正在运行，则会推迟到原处理函数运行完成后的下一个 tick 才触发这次时钟
+      }
+    }
     yield();
-
+  }
   usertrapret();
 }
 
diff --git a/time.txt b/time.txt
new file mode 100644
index 0000000..56a6051
--- /dev/null
+++ b/time.txt
@@ -0,0 +1 @@
+1
\ No newline at end of file
diff --git a/user/find.c b/user/find.c
new file mode 100644
index 0000000..1e432d5
--- /dev/null
+++ b/user/find.c
@@ -0,0 +1,78 @@
+#include "kernel/types.h"
+#include "kernel/fcntl.h"
+#include "kernel/stat.h"
+#include "kernel/fs.h"
+#include "user/user.h"
+
+/*
+	将路径格式化为文件名
+*/
+char* fmt_name(char *path){
+  static char buf[DIRSIZ+1];
+  char *p;
+
+  // Find first character after last slash.
+  for(p=path+strlen(path); p >= path && *p != '/'; p--);
+  p++;
+  memmove(buf, p, strlen(p)+1);
+  return buf;
+}
+/*
+	系统文件名与要查找的文件名，若一致，打印系统文件完整路径
+*/
+void eq_print(char *fileName, char *findName){
+	if(strcmp(fmt_name(fileName), findName) == 0){
+		printf("%s\n", fileName);
+	}
+}
+/*
+	在某路径中查找某文件(主要代码参考ls.c文件)，
+*/
+void find(char *path, char *findName){
+	int fd;
+	struct stat st;	
+	if((fd = open(path, O_RDONLY)) < 0){
+		fprintf(2, "find: cannot open %s\n", path);
+		return;
+	}
+	if(fstat(fd, &st) < 0){
+		fprintf(2, "find: cannot stat %s\n", path);
+		close(fd);
+		return;
+	}
+	char buf[512], *p;	
+	struct dirent de;
+	switch(st.type){	
+        //如果当前是文件，就直接打印其路径与名字
+		case T_FILE:
+			eq_print(path, findName);			
+			break;
+        //如果当前是目录，则进入该目录再查找所需文件
+		case T_DIR:
+			if(strlen(path) + 1 + DIRSIZ + 1 > sizeof buf){
+				printf("find: path too long\n");
+				break;
+			}
+			strcpy(buf, path);
+			p = buf+strlen(buf);
+			*p++ = '/';
+			while(read(fd, &de, sizeof(de)) == sizeof(de)){
+				if(de.inum == 0 || de.inum == 1 || strcmp(de.name, ".")==0 || strcmp(de.name, "..")==0)
+					continue;				
+				memmove(p, de.name, strlen(de.name));
+				p[strlen(de.name)] = 0;
+				find(buf, findName);
+			}
+			break;
+	}
+	close(fd);	
+}
+
+int main(int argc, char *argv[]){
+	if(argc < 3){
+		printf("find: find <path> <fileName>\n");
+		exit(0);
+	}
+	find(argv[1], argv[2]);
+	exit(0);
+}
diff --git a/user/pingpong.c b/user/pingpong.c
new file mode 100644
index 0000000..d1172bd
--- /dev/null
+++ b/user/pingpong.c
@@ -0,0 +1,52 @@
+#include <kernel/types.h>
+#include <user/user.h>
+
+int main(){
+    //(p1)：写端父进程，读端子进程
+    //(p2)；写端子进程，读端父进程
+    int p1[2],p2[2];
+    //来回传输的字符数组：一个字节
+    char buffer[] = {'X'};
+    //传输字符数组的长度
+    long length = sizeof(buffer);
+    //父进程写，子进程读的管道，把read/write文件描述符放在p1[0]和p1[1]中
+    pipe(p1);
+    //子进程写，父进程读的管道，把read/write文件描述符放在p2[0]和p2[1]中
+    pipe(p2);
+    if(fork() == 0){
+        //关掉不用的p1[1]、p2[0]
+        close(p1[1]);
+        close(p2[0]);
+		//子进程从pipe1的读端，读取字符数组
+		if(read(p1[0], buffer, length) != length){
+			printf("a--->b read error!");
+			exit(1);
+		}
+		//打印读取到的字符数组
+		printf("%d: received ping\n", getpid());
+		//子进程向pipe2的写端，写入字符数组
+		if(write(p2[1], buffer, length) != length){
+			printf("a<---b write error!");
+			exit(1);
+		}
+        exit(0);
+    }
+    //关掉不用的p1[0]、p2[1]
+    close(p1[0]);
+    close(p2[1]);
+	//父进程向pipe1的写端，写入字符数组
+	if(write(p1[1], buffer, length) != length){
+		printf("a--->b write error!");
+		exit(1);
+	}
+	//父进程从pipe2的读端，读取字符数组
+	if(read(p2[0], buffer, length) != length){
+		printf("a<---b read error!");
+		exit(1);
+	}
+	//打印读取的字符数组
+	printf("%d: received pong\n", getpid());
+    //等待进程子退出
+    wait(0);
+	exit(0);
+}
diff --git a/user/primes.c b/user/primes.c
new file mode 100644
index 0000000..277aa7d
--- /dev/null
+++ b/user/primes.c
@@ -0,0 +1,51 @@
+#include "kernel/types.h"
+#include "user/user.h"
+
+void func(int *input, int num){
+	if(num == 1){
+		printf("prime %d\n", *input);
+		return;
+	}
+	int p[2],i;
+	int prime = *input;
+	int temp;
+	printf("prime %d\n", prime);
+    //建立管道
+	pipe(p);
+    //向管道中依次写入数据
+    if(fork() == 0){
+        for(i = 0; i < num; i++){
+            temp = *(input + i);
+			write(p[1], (char *)(&temp), 4);
+		}
+        exit(0);
+    }
+	close(p[1]);
+    //读数据，筛去当前数据的倍数（使用埃氏筛）
+	if(fork() == 0){
+		int counter = 0;
+		char buffer[4];
+		while(read(p[0], buffer, 4) != 0){
+			temp = *((int *)buffer);
+			if(temp % prime != 0){
+				*input = temp;
+				input += 1;
+				counter++;
+			}
+		}
+		func(input - counter, counter);
+		exit(0);
+    }
+	wait(0);
+	wait(0);
+}
+
+int main(){
+    int input[34];
+	int i = 0;
+	for(; i < 34; i++){
+		input[i] = i+2;
+	}
+	func(input, 34);
+    exit(0);
+}
diff --git a/user/sleep.c b/user/sleep.c
new file mode 100644
index 0000000..62c3d70
--- /dev/null
+++ b/user/sleep.c
@@ -0,0 +1,13 @@
+#include "kernel/types.h"
+#include "user/user.h"
+
+int main(int argn, char *argv[]){
+	if(argn != 2){
+		fprintf(2, "only 1 argument for sleep\n");
+		exit(1);
+	}
+	int sleepNum = atoi(argv[1]);
+	printf("(sleep for a little while)\n");
+	sleep(sleepNum);
+	exit(0);
+}
diff --git a/user/user.h b/user/user.h
index b71ecda..5df8112 100644
--- a/user/user.h
+++ b/user/user.h
@@ -23,7 +23,9 @@ int getpid(void);
 char* sbrk(int);
 int sleep(int);
 int uptime(void);
-
+//加入系统调用函数声明
+int sigalarm(int ticks, void (*handler)());
+int sigreturn(void);
 // ulib.c
 int stat(const char*, struct stat*);
 char* strcpy(char*, const char*);
diff --git a/user/usys.pl b/user/usys.pl
index 01e426e..3c258dc 100755
--- a/user/usys.pl
+++ b/user/usys.pl
@@ -36,3 +36,5 @@ entry("getpid");
 entry("sbrk");
 entry("sleep");
 entry("uptime");
+entry("sigalarm");
+entry("sigreturn");
\ No newline at end of file
diff --git a/user/xargs.c b/user/xargs.c
new file mode 100644
index 0000000..2c7362a
--- /dev/null
+++ b/user/xargs.c
@@ -0,0 +1,78 @@
+#include "kernel/types.h"
+#include "kernel/stat.h"
+#include "kernel/param.h"
+#include "user/user.h"
+
+void copy(char **p1, char *p2){
+    *p1 = malloc(strlen(p2) + 1);
+    strcpy(*p1, p2);
+}
+int readLine(char **pars, int i){
+    int d = 1024;
+    char buf[d];
+    int j = 0;
+    // 读取1行
+    while (read(0, buf + j, 1)){
+        // 按行划分
+        if (buf[j] == '\n'){
+            buf[j] = 0;
+            break;
+        }
+        j++;
+        if (j == d){
+            fprintf(2, "Parameters are too long!\n");
+            exit(1);
+        }
+    }
+    // 没有读取内容
+    if (j == 0){
+        return -1;
+    }
+    // 按照空格划分
+    int k = 0;
+    while (k < j){
+        if (i > MAXARG){
+            fprintf(2, "Too much parameters!\n");
+            exit(1);
+        }
+        // 忽略
+        while ((k < j) && (buf[k] == ' ')){
+            k++;
+        }
+        // 起始位置
+        int l = k;
+        // 保留字符
+        while ((k < j) && (buf[k] != ' ')){
+            k++;
+        }
+        buf[k++] = 0;
+        copy(&pars[i], buf + l);
+        i++;
+    }
+    return i;
+}
+int main(int argc, char *argv[]){
+    if (argc < 2){
+        printf("Please enter more parameters!\n");
+        exit(1);
+    }
+    else{
+        int i;
+        char *pars[MAXARG];
+        for (i = 1; i < argc; i++){
+            copy(&pars[i - 1], argv[i]);
+        }
+        
+        int end;
+        while ((end = readLine(pars, argc - 1)) != -1){
+            pars[end] = 0;
+            if (fork() == 0){
+                exec(pars[0], pars);
+                exit(1);
+            }else{
+                wait(0);
+            }
+        }
+        exit(0);
+    }
+}
\ No newline at end of file
